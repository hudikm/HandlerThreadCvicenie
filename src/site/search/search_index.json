{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cvi\u010denie - Multithreading \u00b6 Zadanie: \u00dalohou cvi\u010denia je obozn\u00e1mi\u0165 sa s pou\u017eit\u00edm triedy HandlerThread . T\u00e1to trieda bude tvori\u0165 pracovn\u00e9 vl\u00e1kno, ktor\u00e9 odbremen\u00ed hlavn\u00e9 'UI' vl\u00e1kno od n\u00e1ro\u010dn\u00fdch \u00faloh. Vytv\u00e1ran\u00e1 aplik\u00e1cia m\u00e1 za \u00falohu stiahnu\u0165 obr\u00e1zky z internetu a po stiahnut\u00ed ich zobraz\u00ed v pripravenom Layoute. Po\u017eiadavky na aplik\u00e1ciu: Obr\u00e1zky s\u0165ahova\u0165 na pracovnom vl\u00e1kne. Aplik\u00e1cia sa mus\u00ed prisp\u00f4sobi\u0165 \u017eivotn\u00e9mu cyklu aktivity: pri re\u0161tarte aplik\u00e1cie sa pracovn\u00e9 vl\u00e1kno mus\u00ed ukon\u010di\u0165 alebo sa op\u00e4tovne vyu\u017eije pri re\u0161tarte aktivity. Pou\u017ei\u0165 singleton (jedin\u00e1\u010dik) n\u00e1vrhov\u00fd vzor. Vyu\u017ei\u0165 cache pam\u00e4\u0165 na ulo\u017eenie stiahnut\u00fdch obr\u00e1zkov. Vyu\u017ei\u0165 LifeCycle na integrovanie \u017eivotn\u00e9ho cyklu hlavnej aktivity do pracovn\u00e9ho vl\u00e1kna Uk\u00e1\u017eka spolupr\u00e1ce hlavn\u00e9ho a pracovn\u00e9ho vl\u00e1kna Uk\u00e1\u017eka v\u00fdslednej aplik\u00e1cie Postup pr\u00e1ce \u00b6 \u0160tartovac\u00ed projekt naklonujte pomocou pr\u00edkazu: git clone https://github.com/hudikm/HandlerThreadCvicenie.git --branch Start_cvicenia --single-branch Adres\u00e1rov\u00e1 \u0161trukt\u00fara \u0161tartovacieho projektu \u00b6 . \u2514\u2500 app \u2514\u2500 src \u2514\u2500 main \u251c\u2500 res \u2502 \u2514\u2500 layout \u2502 \u2514\u2500 activity_main.xml \u251c\u2500 java \u2502 \u2514\u2500 sk \u2502 \u2514\u2500 uniza \u2502 \u2514\u2500 handlerthreadcvicenie \u2502 \u2514\u2500 MainActivity.java \u2514\u2500 AndroidManifest.xml 1.0 \u00daprava layout-u aplik\u00e1cie \u00b6 Pre jednoduchos\u0165 pou\u017eijeme LinearLayout , ktor\u00fd je vlo\u017een\u00fd do ScrollView ako kontajner na zobrazenie stiahnut\u00fdch obr\u00e1zkov. \ud83d\uddb9 app/src/main/res/layout/activity_main.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:orientation= \"vertical\" tools:context= \".MainActivity\" > <ScrollView android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:layout_gravity= \"center_horizontal\" > <LinearLayout android:id= \"@+id/imageContainer\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:orientation= \"vertical\" > </LinearLayout> </ScrollView> </LinearLayout> 1.1 Vytvorenie MyHandlerThread triedy \u00b6 V\u017edy, ke\u010f je vytvoren\u00e9 nov\u00e9 vl\u00e1kno je vhodn\u00e9 zavola\u0165 setThreadPriority() a nastavi\u0165 vl\u00e1knu vhodn\u00fa prioritu tak aby pl\u00e1nova\u010d vybalancoval vyta\u017eenie CPU. Pre jednoduch\u0161ie zvolenie spr\u00e1vnej priority existuj\u00fa pomocn\u00e9 kon\u0161tanty cez ktor\u00e9 m\u00f4\u017eete zvoli\u0165 spr\u00e1vnu prioritu vi\u010f. Process . Napr\u00edklad THREAD_PRIORITY_DEFAULT predstavuje predvolen\u00fa hodnotu pre vl\u00e1kno. Aplik\u00e1cia by mala nastavi\u0165 prioritu THREAD_PRIORITY_BACKGROUND pre vl\u00e1kna, ktor\u00e9 vykon\u00e1vaj\u00fa menej naliehav\u00fa pr\u00e1cu. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.os.HandlerThread ; import android.os.Process ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu } } 1.2.a Vytvorenie rozhrania, ktor\u00e9 sa pou\u017eije na odovzdanie stiahnut\u00e9ho obr\u00e1zku \u00b6 \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.os.HandlerThread ; import android.os.Process ; import android.widget.ImageView ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu } } Pred \u00fapravou package sk.uniza.handlerthreadcvicenie ; import android.os.HandlerThread ; import android.os.Process ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu } } 1.2.b Pou\u017eitie rozhrania MyHandlerThread.Callback \u00b6 \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.os.Bundle ; import android.widget.ImageView ; import androidx.appcompat.app.AppCompatActivity ; public class MainActivity extends AppCompatActivity implements MyHandlerThread . Callback { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); } @Override public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ) { } } Pred \u00fapravou package sk.uniza.handlerthreadcvicenie ; import android.os.Bundle ; import androidx.appcompat.app.AppCompatActivity ; public class MainActivity extends AppCompatActivity { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); } } 1.3 Vytvorenie pomocnej met\u00f3dy prepareHandler \u00b6 V tomto kroku najprv priprav\u00edme priv\u00e1tny atrib\u00fat typu Handler , ktor\u00fd predstavuje referenciu na pracovn\u00fd handler. Tento Handler bude prij\u00edma\u0165 a spracov\u00e1va\u0165 pridelen\u00e9 pracovn\u00e9 \u00falohy z hlavn\u00e9ho vl\u00e1kna vo forme spr\u00e1v v callback met\u00f3de handleMessage(@NonNull Message msg) . Objekt Message definuje spr\u00e1vu obsahuj\u00facu popis a \u013eubovo\u013en\u00fd d\u00e1tov\u00fd objekt, ktor\u00fd je mo\u017en\u00e9 posla\u0165 obsluhe Handler . Tento objekt obsahuje dve \u010fal\u0161ie int polia a jedno pole extra objektu. Najlep\u0161\u00edm sp\u00f4sobom, ako z\u00edska\u0165 in\u0161tanciu objektu, je zavola\u0165 met\u00f3du Message.obtain() alebo jednu z met\u00f3d Handler.obtainMessage() , ktor\u00e1 ich vytiahne zo skupiny recyklovan\u00fdch objektov. Prepojenie vytvorenej triedy Handler s triedou HandlerThread Trieda HandlerThread obsahuje tzv. Looper , ktor\u00fd treba prepoji\u0165 s vytvorenou triedou Handler . Looper z\u00edskame cez getLooper() a referenciu odovzd\u00e1me cez kon\u0161truktor triedy Handler .( new Handler(getLooper()) ). Warning Ak by sme zavolali pr\u00e1zdny kon\u0161truktor, tak tento Handler by si vy\u017eiadal Looper od vl\u00e1kna na ktorom bol vytvoren\u00fd objekt Handler . V na\u0161om pr\u00edpade by to bolo hlavn\u00e9 vl\u00e1kno a teda v\u0161etky \u00falohy by boli vykonan\u00e9 na hlavnom vl\u00e1kne a nie na pracovnom HandlerThread vl\u00e1kne. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.os.Handler ; import android.os.HandlerThread ; import android.os.Message ; import android.widget.ImageView ; import android.os.Process ; import androidx.annotation.NonNull ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); // Definovanie pracovn\u00e9ho handlera, ktor\u00fd z pridelen\u00e9ho loopera pr\u00edjima // pridelen\u00fa pr\u00e1cu private Handler mWorkerHandler ; // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); Pred \u00fapravou package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.os.HandlerThread ; import android.os.Process ; import android.widget.ImageView ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); public class MyHandlerThread extends HandlerThread { Nov\u00e9 // priority pracovn\u00e9mu vl\u00e1knu } /** * Pomocn\u00e1 met\u00f3da na inicializ\u00e1ciu HandlerThread ako pracovn\u00e9ho vl\u00e1kna */ public void prepareHandler () { mWorkerHandler = new Handler ( getLooper ()) { /* V handleMessage callback met\u00f3de sa spracov\u00e1vaj\u00fa prijat\u00e9 spravy na pracovnom vl\u00e1kne HandlerThread */ @Override public void handleMessage ( @NonNull Message msg ) { // Spracovanie prijatej spr\u00e1vy } }; } } Pred \u00fapravou // priority pracovn\u00e9mu vl\u00e1knu } } 1.4 Vytvorenie pomocnej triedy ImageUrl \u00b6 T\u00e1to pomocn\u00e1 trieda m\u00e1 za \u00falohu definova\u0165 typ spr\u00e1vy pomocou kon\u0161tanty WHAT \u010falej dr\u017ea\u0165 url adresu obr\u00e1zku, ktor\u00fd sa m\u00e1 stiahn\u00fa\u0165 a dr\u017ea\u0165 referenciu na ImageView, v ktorom sa zobraz\u00ed s\u0165iahnut\u00fd obr\u00e1zok. Note Referencia na ImageView v ktorom sa zobraz\u00ed stiahnut\u00fd obr\u00e1zok je vo forme WeakReference , ktor\u00e1 m\u00e1 zabezpe\u010di\u0165 aby nedoch\u00e1dzalo k memory leaku v pr\u00edpade re-\u0161tartovania aplik\u00e1cie. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/ImageUrl.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.widget.ImageView ; import java.lang.ref.WeakReference ; /* D\u00e1tova trieda, ktor\u00e1 reprezentuje jeden obr\u00e1zok, ktor\u00fd sa bude s\u0165ahova\u0165 */ public class ImageUrl { public static final int WHAT = 101 ; // Identifik\u00e1tor spr\u00e1vy public final String urlOfImage ; //url adresa obr\u00e1zku /* Referancia na ImageView v ktorom sa zobraz\u00ed stiahnut\u00fd obr\u00e1zok. T\u00e1to referencia je vo forme WeakReference, ktor\u00e1 m\u00e1 zabezpe\u010di\u0165 aby nedoch\u00e1dzalo k memory leaku v pr\u00edpade restartovania aplik\u00e1cie */ public final WeakReference < ImageView > uiToShowImage ; public ImageUrl ( String urlOfImage , ImageView uiToShowImage ) { this . urlOfImage = urlOfImage ; this . uiToShowImage = new WeakReference <> ( uiToShowImage ); } } 1.5 Vytvorenie met\u00f3dy handleRequest ur\u010denej na stiahnutie obr\u00e1zku z internetu na pracovnom vl\u00e1kne \u00b6 T\u00e1to pomocn\u00e1 met\u00f3da, ktor\u00e1 je spusten\u00e1 na pomocnom vl\u00e1kne ma za \u00falohu pomocou HttpURLConnection stiahnu\u0165 obr\u00e1zok z internetu a n\u00e1sledne ho odovzda\u0165 \u010falej zavolan\u00edm callback met\u00f3dy mCallback.onImageDownloaded , ktor\u00e1 je vykonan\u00e1 na UI vl\u00e1kne. Odovzdanie Runnable objektu na hlavn\u00e9 UI vl\u00e1kno Aby sa callback met\u00f3da vykonala na hlavnom UI vl\u00e1kne, je potrebn\u00e9 ju odovzda\u0165 vo forme pracovn\u00e9ho objektu Runnable cez objekt Handler , ktor\u00fd je pripojen\u00fd k hlavn\u00e9mu vl\u00e1knu ( mResponseHandler inicializ\u00e1cia je zn\u00e1zornen\u00e1 v nasleduj\u00facom kroku). mResponseHandler . post ( new Runnable () { @Override public void run () { // Spusten\u00e9 na UI vl\u00e1kne mCallback . onImageDownloaded ( imageUrl . uiToShowImage . get (), bitmap ); } }); } Note this.sleep(500) simuluje pomal\u00e9 pripojenie na internet. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.graphics.BitmapFactory ; import android.os.Handler ; import android.os.HandlerThread ; import android.os.Message ; import android.os.Trace ; import android.widget.ImageView ; import android.os.Process ; import androidx.annotation.NonNull ; import java.io.IOException ; import java.io.InputStream ; import java.net.HttpURLConnection ; import java.net.URL ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie Pred \u00fapravou package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.os.Handler ; import android.os.HandlerThread ; import android.os.Message ; import android.widget.ImageView ; import android.os.Process ; import androidx.annotation.NonNull ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie public class MyHandlerThread extends HandlerThread { Nov\u00e9 @Override public void handleMessage ( @NonNull Message msg ) { // Spracovanie prijatej spr\u00e1vy } }; } /* Met\u00f3da na stiahnutie obr\u00e1zku z internetu, T\u00e1to met\u00f3da je je spusten\u00e1 na pracovnom vl\u00e1kne! */ private void handleRequest ( final ImageUrl imageUrl ) { try { final Bitmap bitmap ; Trace . beginSection ( \"HTTP download\" ); HttpURLConnection connection = ( HttpURLConnection ) new URL ( imageUrl . urlOfImage ) . openConnection (); connection . setRequestMethod ( \"GET\" ); bitmap = BitmapFactory . decodeStream (( InputStream ) connection . getContent ()); try { this . sleep ( 500 ); } catch ( InterruptedException e ) { e . printStackTrace (); } /* Stiahnut\u00fd obr\u00e1zok sa odovzd\u00e1 s pomocu Handler triedy UI vl\u00e1knu, ktor\u00e9 zavol\u00e1 callback met\u00f3du */ if ( bitmap != null ) { mResponseHandler . post ( new Runnable () { @Override public void run () { // Spusten\u00e9 na UI vl\u00e1kne mCallback . onImageDownloaded ( imageUrl . uiToShowImage . get (), bitmap ); } }); } } catch ( IOException e ) { e . printStackTrace (); } } } Pred \u00fapravou @Override public void handleMessage ( @NonNull Message msg ) { // Spracovanie prijatej spr\u00e1vy } }; } } 1.6 \u00daprava kon\u0161truktora MyHandlerThread \u00b6 V tomto kroku uprav\u00edme kon\u0161truktor tak aby sme z\u00edskali referenciou na Handler objekt, ktor\u00fd je sp\u00e4t\u00fd s hlavn\u00fdm vl\u00e1knom a referenciu na implementovan\u00e9 rozhranie Callback \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java import android.graphics.BitmapFactory; Nov\u00e9 import android.os.Handler ; import android.os.HandlerThread ; import android.os.Message ; import android.os.Process ; import android.os.Trace ; import android.widget.ImageView ; import androidx.annotation.NonNull ; Pred \u00fapravou import android.os.Handler ; import android.os.HandlerThread ; import android.os.Message ; import android.os.Trace ; import android.widget.ImageView ; import android.os.Process ; import androidx.annotation.NonNull ; public class MyHandlerThread extends HandlerThread { Nov\u00e9 // pridelen\u00fa pr\u00e1cu private Handler mWorkerHandler ; // Referencia na Handler, ktor\u00fd je sp\u00e4t\u00fd s UI vl\u00e1knom private Handler mResponseHandler ; // Referencia na Callback rozhranie private Callback mCallback ; // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread ( Handler responseHandler , Callback callback ) { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu mResponseHandler = responseHandler ; mCallback = callback ; } /** Pred \u00fapravou // pridelen\u00fa pr\u00e1cu private Handler mWorkerHandler ; // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu } /** 1.7 Spracovanie prijatej spr\u00e1vy v handleMessage met\u00f3de \u00b6 Ak prijat\u00e1 spr\u00e1va obsahuje objekt, ktor\u00fd je typu ImageUrl tak ho odo\u0161leme na spracovanie do met\u00f3dy handleRequest , ktor\u00e1 dan\u00fd obr\u00e1zok stiahne z internetu. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java public class MyHandlerThread extends HandlerThread { Nov\u00e9 @Override public void handleMessage ( @NonNull Message msg ) { // Spracovanie prijatej spr\u00e1vy // Stiahnutie obr\u00e1zkov z internetu if ( msg . obj != null && msg . obj instanceof ImageUrl ) { handleRequest (( ImageUrl ) msg . obj ); } } }; } Pred \u00fapravou @Override public void handleMessage ( @NonNull Message msg ) { // Spracovanie prijatej spr\u00e1vy } }; } 1.8 Vytvorenie a inicializovanie novej in\u0161tancie MyHandlerThread \u00b6 V predch\u00e1dzaj\u00facom kroku sme si upravili kon\u0161truktor triedy MyHandlerThread a teraz si pomocou neho vytvor\u00edme nov\u00fa in\u0161tanciu tejto triedy. Note V kroku 1.4 sme triedu Handler museli prepoji\u0165 manu\u00e1lne s Looperom pomocou met\u00f3dy getLooper . V tomto pr\u00edpade pr\u00e1zdny kon\u0161tuktor automaticky pripoj\u00ed Looper hlavn\u00e9ho vl\u00e1kna s triedou Handler . \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java package sk.uniza.handlerthreadcvicenie; Nov\u00e9 import android.graphics.Bitmap ; import android.os.Bundle ; import android.os.Handler ; import android.widget.ImageView ; import android.widget.LinearLayout ; import androidx.appcompat.app.AppCompatActivity ; public class MainActivity extends AppCompatActivity implements MyHandlerThread . Callback { private LinearLayout imageContainer ; private MyHandlerThread myHandlerThread ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); myHandlerThread = new MyHandlerThread ( new Handler (), this ); myHandlerThread . start (); myHandlerThread . prepareHandler (); } @Override Pred \u00fapravou import android.graphics.Bitmap ; import android.os.Bundle ; import android.widget.ImageView ; import androidx.appcompat.app.AppCompatActivity ; public class MainActivity extends AppCompatActivity implements MyHandlerThread . Callback { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); } @Override 1.9 Vytvorenie a odoslanie zoznamu obr\u00e1zkov na stiahnutie \u00b6 \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java import androidx.appcompat.app.AppCompatActivity; Nov\u00e9 public class MainActivity extends AppCompatActivity implements MyHandlerThread . Callback { // Url online slu\u017eby, ktor\u00e1 generuje obr\u00e1zky s textom private String imageUrlLink = \"https://dummyimage.com/300/09f/fff\" + \".png&text=\" ; private LinearLayout imageContainer ; private MyHandlerThread myHandlerThread ; Pred \u00fapravou public class MainActivity extends AppCompatActivity implements MyHandlerThread . Callback { private LinearLayout imageContainer ; private MyHandlerThread myHandlerThread ; public class MainActivity extends AppCompatActivity Nov\u00e9 protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); imageContainer = findViewById ( R . id . imageContainer ); myHandlerThread = new MyHandlerThread ( new Handler (), this ); myHandlerThread . start (); myHandlerThread . prepareHandler (); } @Override protected void onStart () { super . onStart (); for ( Integer i = 0 ; i < 10 ; i ++ ) { ImageView imageView = new ImageView ( this ); // Informa\u010dn\u00fd obr\u00e1zok, \u017ee prebieha \u0161tahovanie imageView . setImageResource ( R . drawable . loading ); imageContainer . addView ( imageView ); // Zavolanie pomocnej met\u00f3dy na ulo\u017eenie spr\u00e1vy do z\u00e1sob\u00edka. // Spr\u00e1vy zo z\u00e1sobn\u00edka s\u00fa spracovan\u00e9 na pracovnom vl\u00e1kne myHandlerThread . queueTask ( new ImageUrl ( imageUrlLink . concat ( \"img+\" + i ), imageView )); } } @Override public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ) { Pred \u00fapravou protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); myHandlerThread = new MyHandlerThread ( new Handler (), this ); myHandlerThread . start (); myHandlerThread . prepareHandler (); } @Override public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ) { Vytvorenie pomocnej met\u00f3dy na posunutie spr\u00e1vy pracovn\u00e9mu HandlerThread vl\u00e1knu. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java public class MyHandlerThread extends HandlerThread { Nov\u00e9 }; } /** * Pomocn\u00e1 met\u00f3da na posunutie spr\u00e1vy pracovn\u00e9mu HandlerThread vl\u00e1knu * * @param imageUrl - obr\u00e1zok, ktor\u00fd sa m\u00e1 stiahnu\u0165 */ public void queueTask ( ImageUrl imageUrl ) { mWorkerHandler . obtainMessage ( imageUrl . WHAT , imageUrl ) . sendToTarget (); } /* Met\u00f3da na stiahnutie obr\u00e1zku z internetu , T\u00e1to met\u00f3da je je spusten\u00e1 na pracovnom vl\u00e1kne ! Pred \u00fapravou }; } /* Met\u00f3da na stiahnutie obr\u00e1zku z internetu , T\u00e1to met\u00f3da je je spusten\u00e1 na pracovnom vl\u00e1kne ! 1.10 Zobrazenie stiahnut\u00e9ho obr\u00e1zku \u00b6 \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java public class MainActivity extends AppCompatActivity Nov\u00e9 @Override public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ) { // Otestovanie \u010di ImageView bol vytvoren\u00fd v rovnakom kontexte. V // pr\u00edpade re\u0161tatovania aplik\u00e1cie, mo\u017ee ImageView poch\u00e1dza\u0165 z u\u017e // zaniknutej in\u0161tancie Aplik\u00e1cie. if ( imageView . getContext () == this ) imageView . setImageBitmap ( bitmap ); } } Pred \u00fapravou @Override public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ) { } } 1.11 Pridanie povolenia pre pr\u00edstup na internet \u00b6 \ud83d\uddb9 app/src/main/AndroidManifest.xml Nov\u00e9 < manifest xmlns : android = \"http://schemas.android.com/apk/res/android\" package = \"sk.uniza.handlerthreadcvicenie\" > < uses - permission android : name = \"android.permission.INTERNET\" /> < application android : allowBackup = \"true\" android : icon = \"@mipmap/ic_launcher\" Pred \u00fapravou < manifest xmlns : android = \"http://schemas.android.com/apk/res/android\" package = \"sk.uniza.handlerthreadcvicenie\" > < application android : allowBackup = \"true\" android : icon = \"@mipmap/ic_launcher\" Note Po tomto kroku by mala by\u0165 aplik\u00e1cia spustite\u013en\u00e1 a funk\u010dn\u00e1. Ale pri re\u0161tarte v plyvom konfigura\u010dnej zmeny(napr. rotacia obrazovky) doch\u00e1dza pri op\u00e4tovnom spusten\u00ed k vytvoreniu novej in\u0161tancie MyHandlerThreadu . \u013dubovoln\u00e9 pracovn\u00e9 vl\u00e1kno( Thread , HandlerThread alebo aj vl\u00e1kno sp\u00e4t\u00e9 s AsyncTask ) nie je ovplyvnen\u00e9m \u017eivotn\u00fdm cyklom aktivity, \u010do znamen\u00e1, \u017ee bude na pozad\u00ed be\u017ea\u0165 \u010falej. \u010c\u00edm viacej budeme ot\u00e1\u010da\u0165 zariadenia t\u00fdm viac in\u0161tanci\u00ed n\u00e1m bude vznika\u0165. vi\u010f obr\u00e1zok s CPU profilera: Okrem vzniku nov\u00fdch in\u0161tanci\u00ed, ka\u017ed\u00e9 pracovn\u00e9 vl\u00e1kno malo frontu pridelen\u00fdch spr\u00e1v a teda v\u0161etky vl\u00e1kna, ktor\u00e9 e\u0161te nevypr\u00e1zdnili svoju frontu \u00faloh \u010falej s\u0165ahovali obr\u00e1zky aj ke\u010f sa u\u017e nepou\u017eij\u00fa. vi\u010f obr\u00e1zok s CPU profilera: Jednoduch\u00e9 rie\u0161enie toho probl\u00e9mu je uk\u00e1zan\u00e9 v nasleduj\u00facom kroku. 1.12 Re\u0161tart aplik\u00e1cie vplyvom konfigura\u010dnej zmeny. Minim\u00e1lne rie\u0161enie \u00b6 Zavolan\u00edm v met\u00f3de onDestroy met\u00f3du z triedy HandlerThread .quit() vyma\u017eeme zvy\u0161n\u00e9 \u00falohy z fronty spr\u00e1v, ktor\u00e9 e\u0161te neboli spracovan\u00e9. Na aktu\u00e1lne vykon\u00e1van\u00fa \u00falohu to nem\u00e1 vplyv a teda obr\u00e1zok sa stiahne. HandlerThread vl\u00e1kno prejde do 'idle' stavu a \u010dasom ho syst\u00e9m odstr\u00e1ni. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; Pred \u00fapravou package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; public class MainActivity extends AppCompatActivity Nov\u00e9 if ( imageView . getContext () == this ) imageView . setImageBitmap ( bitmap ); } @Override protected void onDestroy () { super . onDestroy (); myHandlerThread . quit (); } } Pred \u00fapravou if ( imageView . getContext () == this ) imageView . setImageBitmap ( bitmap ); } } 2.0 Vyu\u017eitie Singleton (jedin\u00e1\u010dik) n\u00e1vrhov\u00e9ho vzoru \u00b6 V predch\u00e1dzaj\u00facom pr\u00edpade pri ka\u017edom re\u0161tarte aplik\u00e1cie n\u00e1m vznik\u00e1 nov\u00e1 in\u0161tancia triedy MyHandlerThread , \u010do nieje optim\u00e1lne rie\u0161enie. V tomto kroku prerob\u00edme p\u00f4vodn\u00e9 rie\u0161enie s vyu\u017eit\u00edm n\u00e1vrhov\u00e9ho vzoru Singleton, tak aby existovala iba jedna jedin\u00e1 in\u0161tancia triedy MyHandlerThread . Note Singleton (jednin\u00e1\u010dik) znamen\u00e1, \u017ee trieda, ktor\u00e1 implementuje tento n\u00e1vrhov\u00fd vzor, m\u00e1 iba jednu jedin\u00fa in\u0161tanciu v celom programe. T\u00e1to in\u0161tancie je zdie\u013ean\u00e1 medzi jednotliv\u00fdmi komponentami aplik\u00e1cie. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java public class MainActivity extends AppCompatActivity Nov\u00e9 super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); imageContainer = findViewById ( R . id . imageContainer ); myHandlerThread = MyHandlerThread . getInstance ( new Handler (), this ); if ( ! myHandlerThread . isAlive ()) { // Iba pri prvom spusten\u00ed mus\u00ed prebehn\u00fa\u0165 inicializ\u00e1cia // HandlerThread triedy myHandlerThread . start (); myHandlerThread . prepareHandler (); } } @Override Pred \u00fapravou super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); imageContainer = findViewById ( R . id . imageContainer ); myHandlerThread = new MyHandlerThread ( new Handler (), this ); myHandlerThread . start (); myHandlerThread . prepareHandler (); } @Override public class MainActivity extends AppCompatActivity Nov\u00e9 @Override protected void onDestroy () { super . onDestroy (); } } Pred \u00fapravou @Override protected void onDestroy () { super . onDestroy (); myHandlerThread . quit (); } } \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java import java.net.URL; Nov\u00e9 public class MyHandlerThread extends HandlerThread { // Referencia na vytvoren\u00fa \u0161tanciu MyHandlerThread private static MyHandlerThread instance = null ; // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); Pred \u00fapravou public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); public class MyHandlerThread extends HandlerThread { Nov\u00e9 public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu } public static MyHandlerThread getInstance ( @NonNull Handler responseHandler , @NonNull Callback callback ) { if ( instance == null || ! instance . isAlive ()) { instance = new MyHandlerThread (); } instance . mResponseHandler = responseHandler ; instance . mCallback = callback ; return instance ; } /** Pred \u00fapravou public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread ( Handler responseHandler , Callback callback ) { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu mResponseHandler = responseHandler ; mCallback = callback ; } /** 2.1 Optimaliz\u00e1cia s pohladu re\u0161tartovania aktivity \u00b6 \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java public class MainActivity extends AppCompatActivity Nov\u00e9 @Override protected void onDestroy () { super . onDestroy (); myHandlerThread . onDestroy (); } } Pred \u00fapravou @Override protected void onDestroy () { super . onDestroy (); } } \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java public class MyHandlerThread extends HandlerThread { Nov\u00e9 . sendToTarget (); } /** * Pomocn\u00e1 met\u00f3da, ktor\u00e1 m\u00e1 by\u0165 spusten\u00e1 ke\u010f d\u00f4jde k re\u0161tartu aktivity */ public void onDestroy () { // Odstr\u00e1nenie v\u0161etk\u00fdch e\u0161te nestiahnut\u00fdch url adries so z\u00e1sobn\u00edka mWorkerHandler . removeMessages ( ImageUrl . WHAT ); } /* Met\u00f3da na stiahnutie obr\u00e1zku z internetu , T\u00e1to met\u00f3da je je spusten\u00e1 na pracovnom vl\u00e1kne ! Pred \u00fapravou . sendToTarget (); } /* Met\u00f3da na stiahnutie obr\u00e1zku z internetu , T\u00e1to met\u00f3da je je spusten\u00e1 na pracovnom vl\u00e1kne ! 2.2 Bezpe\u010dn\u00fd pr\u00edstupu k zdie\u013ean\u00fdm premenn\u00fdm z viacer\u00fdch vl\u00e1ken \u00b6 V pr\u00edpade, kedy k zdie\u013ean\u00fdm premenn\u00fdm pristupuje viacero vl\u00e1ken, je nutn\u00e9 zabezpe\u010di\u0165 tento pr\u00edstup synchronization blokom do ktor\u00e9 ma pr\u00edstup v \u010dase iba jedin\u00e9 vl\u00e1kno. T\u00e1to problematika je rozsiahla, ale je nutn\u00e9 jej porozumie\u0165 aby n\u00e1m aplik\u00e1cia fungovala za v\u0161etk\u00fdch okolnost\u00ed. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java public class MyHandlerThread extends HandlerThread { Nov\u00e9 private volatile Handler mResponseHandler ; // Referencia na Callback rozhranie private Callback mCallback ; // Objekt ur\u010den\u00fd na zabezpe\u010denie bezpe\u010dn\u00e9ho pr\u00edstupu pri vyu\u017eit\u00ed vl\u00e1ken private volatile Object syncObj = new Object (); // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { Pred \u00fapravou private Handler mResponseHandler ; // Referencia na Callback rozhranie private Callback mCallback ; // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public class MyHandlerThread extends HandlerThread { Nov\u00e9 if ( instance == null || ! instance . isAlive ()) { instance = new MyHandlerThread (); } synchronized ( instance . syncObj ) { instance . mResponseHandler = responseHandler ; instance . mCallback = callback ; } return instance ; } Pred \u00fapravou if ( instance == null || ! instance . isAlive ()) { instance = new MyHandlerThread (); } instance . mResponseHandler = responseHandler ; instance . mCallback = callback ; return instance ; } public class MyHandlerThread extends HandlerThread { Nov\u00e9 public void onDestroy () { // Odstr\u00e1nenie v\u0161etk\u00fdch e\u0161te nestiahnut\u00fdch url adries so z\u00e1sobn\u00edka mWorkerHandler . removeMessages ( ImageUrl . WHAT ); // Bezpe\u010dn\u00e9 vynulovanie referencie na Handler, ktor\u00fd pri re\u0161tarte // aktivity bude po dobu re\u0161tartu neplatn\u00e1 synchronized ( syncObj ) { mResponseHandler = null ; } } /* Pred \u00fapravou public void onDestroy () { // Odstr\u00e1nenie v\u0161etk\u00fdch e\u0161te nestiahnut\u00fdch url adries so z\u00e1sobn\u00edka mWorkerHandler . removeMessages ( ImageUrl . WHAT ); } /* public class MyHandlerThread extends HandlerThread { Nov\u00e9 Stiahnut\u00fd obr\u00e1zok sa odovzd\u00e1 s pomocu Handler triedy UI vl\u00e1knu , ktor\u00e9 zavol\u00e1 callback met\u00f3du */ // Bezpe\u010dn\u00fd pr\u00edstup z pracovn\u00e9ho vl\u00e1kna synchronized ( syncObj ) { // Overenie, \u017ee referencia na Handler je platn\u00e1 if ( mResponseHandler != null && bitmap != null ) { mResponseHandler . post ( new Runnable () { @Override public void run () { // Spusten\u00e9 na UI vl\u00e1kne mCallback . onImageDownloaded ( imageUrl . uiToShowImage . get (), bitmap ); } }); } } } catch ( IOException e ) { Pred \u00fapravou Stiahnut\u00fd obr\u00e1zok sa odovzd\u00e1 s pomocu Handler triedy UI vl\u00e1knu , ktor\u00e9 zavol\u00e1 callback met\u00f3du */ if ( bitmap != null ) { mResponseHandler . post ( new Runnable () { @Override public void run () { // Spusten\u00e9 na UI vl\u00e1kne mCallback . onImageDownloaded ( imageUrl . uiToShowImage . get (), bitmap ); } }); } } catch ( IOException e ) { 2.3 Aplikovanie Cache na r\u00fdchle na\u010d\u00edtanie u\u017e stiahnut\u00fdch obr\u00e1zkov \u00b6 Pre zamedzenie op\u00e4tovn\u00e9ho s\u0165ahovania implementujeme LRU cache do ktorej budeme zapisova\u0165 stiahnut\u00e9 obr\u00e1zky a pri re\u0161tarte sa obr\u00e1zky miesto internetu na\u010d\u00edtaj\u00fa z tejto cache. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java import android.os.Handler; Nov\u00e9 import android.os.HandlerThread ; import android.os.Message ; import android.os.Process ; import android.widget.ImageView ; import androidx.annotation.NonNull ; import androidx.collection.LruCache ; import java.io.IOException ; import java.io.InputStream ; Pred \u00fapravou import android.os.HandlerThread ; import android.os.Message ; import android.os.Process ; import android.os.Trace ; import android.widget.ImageView ; import androidx.annotation.NonNull ; import java.io.IOException ; import java.io.InputStream ; public class MyHandlerThread extends HandlerThread { Nov\u00e9 public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } // Cache na ulo\u017eenie s\u0165ahovan\u00fdch obr\u00e1zkov final int cacheSize = 4 * 1024 * 1024 ; // 4MiB LruCache < String , Bitmap > bitmapCache = new LruCache < String , Bitmap > ( cacheSize ) { protected int sizeOf ( String key , Bitmap value ) { return value . getByteCount (); } }; public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie Pred \u00fapravou public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie public class MyHandlerThread extends HandlerThread { Nov\u00e9 try { final Bitmap bitmap ; // Na\u010d\u00edtanie obr\u00e1zku z cache(kl\u00fa\u010d je url adresa obr\u00e1zku), ak nebol // n\u00e1jden\u00fd met\u00f3da vr\u00e1ti null hodnotu Bitmap bitmapTmp = bitmapCache . get ( imageUrl . urlOfImage ); if ( bitmapTmp == null ) { HttpURLConnection connection = ( HttpURLConnection ) new URL ( imageUrl . urlOfImage ) . openConnection (); connection . setRequestMethod ( \"GET\" ); bitmap = BitmapFactory . decodeStream (( InputStream ) connection . getContent ()); bitmapCache . put ( imageUrl . urlOfImage , bitmap ); try { this . sleep ( 500 ); } catch ( InterruptedException e ) { e . printStackTrace (); } } else { bitmap = bitmapTmp ; } /* Stiahnut\u00fd obr\u00e1zok sa odovzd\u00e1 s pomocu Handler triedy UI vl\u00e1knu , ktor\u00e9 zavol\u00e1 callback met\u00f3du Pred \u00fapravou try { final Bitmap bitmap ; Trace . beginSection ( \"HTTP download\" ); HttpURLConnection connection = ( HttpURLConnection ) new URL ( imageUrl . urlOfImage ) . openConnection (); connection . setRequestMethod ( \"GET\" ); bitmap = BitmapFactory . decodeStream (( InputStream ) connection . getContent ()); try { this . sleep ( 500 ); } catch ( InterruptedException e ) { e . printStackTrace (); } /* Stiahnut\u00fd obr\u00e1zok sa odovzd\u00e1 s pomocu Handler triedy UI vl\u00e1knu , ktor\u00e9 zavol\u00e1 callback met\u00f3du 3.0 Implementovanie LifeCycle AndroidX komponentu \u00b6 Komponenty, ktor\u00e9 vn\u00edmaj\u00fa \u017eivotn\u00fd cyklus vykon\u00e1vaj\u00fa ur\u010dit\u00e9 akcie pri zmene stavu \u017eivotn\u00e9ho cyklu in\u00e9ho komponentu, ako s\u00fa aktivity a fragmenty. Tieto komponenty v\u00e1m pom\u00f4\u017eu vytvori\u0165 lep\u0161ie usporiadan\u00fd a \u010dasto \u0161t\u00edhlej\u0161\u00ed k\u00f3d, ktor\u00fd sa \u013eah\u0161ie udr\u017euje. Be\u017en\u00fdm vzorcom je implement\u00e1cia \u010dinnost\u00ed z\u00e1visl\u00fdch komponentov do \u017eivotn\u00e9ho cyklu met\u00f3d aktiv\u00edt alebo fragmentov. Tento model v\u0161ak vedie k zlej organiz\u00e1cii k\u00f3d ak mno\u017eeniu ch\u00fdb. Pou\u017eit\u00edm komponentov s vyu\u017eit\u00edm LifeCycle \u017eivotn\u00e9ho cyklu m\u00f4\u017eete presun\u00fa\u0165 k\u00f3d z\u00e1visl\u00fdch komponentov z met\u00f3d \u017eivotn\u00e9ho cyklu aktivity/fragmentu do samotn\u00fdch komponentov. androidx.lifecycle Bal\u00ed\u010dek obsahuje triedy a rozhrania, ktor\u00e9 umo\u017e\u0148uj\u00fa vytv\u00e1ra\u0165 komponenty, ktor\u00e9 s\u00fa s\u00fa\u010das\u0165ou \u017eivotn\u00e9ho cyklu aktivity/fragmentu, ktor\u00e9 m\u00f4\u017eu automaticky upravi\u0165 svoje spr\u00e1vanie v z\u00e1vislosti na aktu\u00e1lnom stave \u017eivotn\u00e9ho cyklu aktivity alebo fragmentu. V\u00e4\u010d\u0161ina komponentov aplik\u00e1cie, ktor\u00e9 s\u00fa definovan\u00e9 v platforme Android Framework, je k nim pripojen\u00e1 so \u017eivotn\u00fdm cyklom. \u017divotn\u00e9 cykly s\u00fa spravovan\u00e9 opera\u010dn\u00fdm syst\u00e9mom alebo Framework k\u00f3dom be\u017eiacim vo va\u0161om procese. S\u00fa z\u00e1kladom fungovania syst\u00e9mu Android a va\u0161a aplik\u00e1cia ich mus\u00ed re\u0161pektova\u0165. Ak tak neurob\u00edte, m\u00f4\u017ee to sp\u00f4sobi\u0165 memory leak alebo dokonca zlyhanie aplik\u00e1cie. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java public class MainActivity extends AppCompatActivity Nov\u00e9 super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); imageContainer = findViewById ( R . id . imageContainer ); myHandlerThread = MyHandlerThread . getInstance ( new Handler (), this , getLifecycle ()); if ( ! myHandlerThread . isAlive ()) { // Iba pri prvom spusten\u00ed mus\u00ed prebehn\u00fa\u0165 inicializ\u00e1cia Pred \u00fapravou super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); imageContainer = findViewById ( R . id . imageContainer ); myHandlerThread = MyHandlerThread . getInstance ( new Handler (), this ); if ( ! myHandlerThread . isAlive ()) { // Iba pri prvom spusten\u00ed mus\u00ed prebehn\u00fa\u0165 inicializ\u00e1cia public class MainActivity extends AppCompatActivity Nov\u00e9 imageView . setImageBitmap ( bitmap ); } @Override protected void onDestroy () { super . onDestroy (); } } Pred \u00fapravou imageView . setImageBitmap ( bitmap ); } @Override protected void onDestroy () { super . onDestroy (); myHandlerThread . onDestroy (); } } \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java import android.widget.ImageView; Nov\u00e9 import androidx.annotation.NonNull ; import androidx.collection.LruCache ; import androidx.lifecycle.Lifecycle ; import androidx.lifecycle.LifecycleObserver ; import androidx.lifecycle.OnLifecycleEvent ; import java.io.IOException ; import java.io.InputStream ; import java.net.HttpURLConnection ; import java.net.URL ; public class MyHandlerThread extends HandlerThread implements LifecycleObserver { // Referencia na vytvoren\u00fa \u0161tanciu MyHandlerThread private static MyHandlerThread instance = null ; Pred \u00fapravou import androidx.annotation.NonNull ; import androidx.collection.LruCache ; import java.io.IOException ; import java.io.InputStream ; import java.net.HttpURLConnection ; import java.net.URL ; public class MyHandlerThread extends HandlerThread { // Referencia na vytvoren\u00fa \u0161tanciu MyHandlerThread private static MyHandlerThread instance = null ; public class MyHandlerThread extends HandlerThread { Nov\u00e9 } public static MyHandlerThread getInstance ( @NonNull Handler responseHandler , @NonNull Callback callback , @NonNull Lifecycle lifecycle ) { if ( instance == null || ! instance . isAlive ()) { instance = new MyHandlerThread (); Pred \u00fapravou } public static MyHandlerThread getInstance ( @NonNull Handler responseHandler , @NonNull Callback callback ) { if ( instance == null || ! instance . isAlive ()) { instance = new MyHandlerThread (); public class MyHandlerThread extends HandlerThread { Nov\u00e9 synchronized ( instance . syncObj ) { instance . mResponseHandler = responseHandler ; instance . mCallback = callback ; // Zaregistrovanie LifeCycleObserver, ktor\u00fdm je t\u00e1to trieda // pripojen\u00e1 na \u017eivotn\u00fd cyklus nadradenej aktivity lifecycle . addObserver ( instance ); } return instance ; } Pred \u00fapravou synchronized ( instance . syncObj ) { instance . mResponseHandler = responseHandler ; instance . mCallback = callback ; } return instance ; } public class MyHandlerThread extends HandlerThread { Nov\u00e9 /** * Pomocn\u00e1 met\u00f3da, ktor\u00e1 m\u00e1 by\u0165 spusten\u00e1 ke\u010f d\u00f4jde k re\u0161tartu aktivity * T\u00e1to met\u00f3da je teraz pripojen\u00e1 na \u017eivotn\u00fd cyklus nadradenej aktivity */ @OnLifecycleEvent ( Lifecycle . Event . ON_DESTROY ) public void onDestroy () { // Odstr\u00e1nenie v\u0161etk\u00fdch e\u0161te nestiahnut\u00fdch url adries so z\u00e1sobn\u00edka mWorkerHandler . removeMessages ( ImageUrl . WHAT ); Pred \u00fapravou /** * Pomocn\u00e1 met\u00f3da, ktor\u00e1 m\u00e1 by\u0165 spusten\u00e1 ke\u010f d\u00f4jde k re\u0161tartu aktivity */ public void onDestroy () { // Odstr\u00e1nenie v\u0161etk\u00fdch e\u0161te nestiahnut\u00fdch url adries so z\u00e1sobn\u00edka mWorkerHandler . removeMessages ( ImageUrl . WHAT );","title":"Home"},{"location":"#cvicenie-multithreading","text":"Zadanie: \u00dalohou cvi\u010denia je obozn\u00e1mi\u0165 sa s pou\u017eit\u00edm triedy HandlerThread . T\u00e1to trieda bude tvori\u0165 pracovn\u00e9 vl\u00e1kno, ktor\u00e9 odbremen\u00ed hlavn\u00e9 'UI' vl\u00e1kno od n\u00e1ro\u010dn\u00fdch \u00faloh. Vytv\u00e1ran\u00e1 aplik\u00e1cia m\u00e1 za \u00falohu stiahnu\u0165 obr\u00e1zky z internetu a po stiahnut\u00ed ich zobraz\u00ed v pripravenom Layoute. Po\u017eiadavky na aplik\u00e1ciu: Obr\u00e1zky s\u0165ahova\u0165 na pracovnom vl\u00e1kne. Aplik\u00e1cia sa mus\u00ed prisp\u00f4sobi\u0165 \u017eivotn\u00e9mu cyklu aktivity: pri re\u0161tarte aplik\u00e1cie sa pracovn\u00e9 vl\u00e1kno mus\u00ed ukon\u010di\u0165 alebo sa op\u00e4tovne vyu\u017eije pri re\u0161tarte aktivity. Pou\u017ei\u0165 singleton (jedin\u00e1\u010dik) n\u00e1vrhov\u00fd vzor. Vyu\u017ei\u0165 cache pam\u00e4\u0165 na ulo\u017eenie stiahnut\u00fdch obr\u00e1zkov. Vyu\u017ei\u0165 LifeCycle na integrovanie \u017eivotn\u00e9ho cyklu hlavnej aktivity do pracovn\u00e9ho vl\u00e1kna Uk\u00e1\u017eka spolupr\u00e1ce hlavn\u00e9ho a pracovn\u00e9ho vl\u00e1kna Uk\u00e1\u017eka v\u00fdslednej aplik\u00e1cie","title":"Cvi\u010denie - Multithreading"},{"location":"#postup-prace","text":"\u0160tartovac\u00ed projekt naklonujte pomocou pr\u00edkazu: git clone https://github.com/hudikm/HandlerThreadCvicenie.git --branch Start_cvicenia --single-branch","title":"Postup pr\u00e1ce"},{"location":"#adresarova-struktura-startovacieho-projektu","text":". \u2514\u2500 app \u2514\u2500 src \u2514\u2500 main \u251c\u2500 res \u2502 \u2514\u2500 layout \u2502 \u2514\u2500 activity_main.xml \u251c\u2500 java \u2502 \u2514\u2500 sk \u2502 \u2514\u2500 uniza \u2502 \u2514\u2500 handlerthreadcvicenie \u2502 \u2514\u2500 MainActivity.java \u2514\u2500 AndroidManifest.xml","title":"Adres\u00e1rov\u00e1 \u0161trukt\u00fara \u0161tartovacieho projektu"},{"location":"#10-uprava-layout-u-aplikacie","text":"Pre jednoduchos\u0165 pou\u017eijeme LinearLayout , ktor\u00fd je vlo\u017een\u00fd do ScrollView ako kontajner na zobrazenie stiahnut\u00fdch obr\u00e1zkov. \ud83d\uddb9 app/src/main/res/layout/activity_main.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:orientation= \"vertical\" tools:context= \".MainActivity\" > <ScrollView android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:layout_gravity= \"center_horizontal\" > <LinearLayout android:id= \"@+id/imageContainer\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:orientation= \"vertical\" > </LinearLayout> </ScrollView> </LinearLayout>","title":"1.0 \u00daprava layout-u aplik\u00e1cie"},{"location":"#11-vytvorenie-myhandlerthread-triedy","text":"V\u017edy, ke\u010f je vytvoren\u00e9 nov\u00e9 vl\u00e1kno je vhodn\u00e9 zavola\u0165 setThreadPriority() a nastavi\u0165 vl\u00e1knu vhodn\u00fa prioritu tak aby pl\u00e1nova\u010d vybalancoval vyta\u017eenie CPU. Pre jednoduch\u0161ie zvolenie spr\u00e1vnej priority existuj\u00fa pomocn\u00e9 kon\u0161tanty cez ktor\u00e9 m\u00f4\u017eete zvoli\u0165 spr\u00e1vnu prioritu vi\u010f. Process . Napr\u00edklad THREAD_PRIORITY_DEFAULT predstavuje predvolen\u00fa hodnotu pre vl\u00e1kno. Aplik\u00e1cia by mala nastavi\u0165 prioritu THREAD_PRIORITY_BACKGROUND pre vl\u00e1kna, ktor\u00e9 vykon\u00e1vaj\u00fa menej naliehav\u00fa pr\u00e1cu. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.os.HandlerThread ; import android.os.Process ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu } }","title":"1.1 Vytvorenie MyHandlerThread triedy"},{"location":"#12a-vytvorenie-rozhrania-ktore-sa-pouzije-na-odovzdanie-stiahnuteho-obrazku","text":"\ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.os.HandlerThread ; import android.os.Process ; import android.widget.ImageView ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu } } Pred \u00fapravou package sk.uniza.handlerthreadcvicenie ; import android.os.HandlerThread ; import android.os.Process ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu } }","title":"1.2.a Vytvorenie rozhrania, ktor\u00e9 sa pou\u017eije na odovzdanie stiahnut\u00e9ho obr\u00e1zku"},{"location":"#12b-pouzitie-rozhrania-myhandlerthreadcallback","text":"\ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.os.Bundle ; import android.widget.ImageView ; import androidx.appcompat.app.AppCompatActivity ; public class MainActivity extends AppCompatActivity implements MyHandlerThread . Callback { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); } @Override public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ) { } } Pred \u00fapravou package sk.uniza.handlerthreadcvicenie ; import android.os.Bundle ; import androidx.appcompat.app.AppCompatActivity ; public class MainActivity extends AppCompatActivity { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); } }","title":"1.2.b Pou\u017eitie rozhrania MyHandlerThread.Callback"},{"location":"#13-vytvorenie-pomocnej-metody-preparehandler","text":"V tomto kroku najprv priprav\u00edme priv\u00e1tny atrib\u00fat typu Handler , ktor\u00fd predstavuje referenciu na pracovn\u00fd handler. Tento Handler bude prij\u00edma\u0165 a spracov\u00e1va\u0165 pridelen\u00e9 pracovn\u00e9 \u00falohy z hlavn\u00e9ho vl\u00e1kna vo forme spr\u00e1v v callback met\u00f3de handleMessage(@NonNull Message msg) . Objekt Message definuje spr\u00e1vu obsahuj\u00facu popis a \u013eubovo\u013en\u00fd d\u00e1tov\u00fd objekt, ktor\u00fd je mo\u017en\u00e9 posla\u0165 obsluhe Handler . Tento objekt obsahuje dve \u010fal\u0161ie int polia a jedno pole extra objektu. Najlep\u0161\u00edm sp\u00f4sobom, ako z\u00edska\u0165 in\u0161tanciu objektu, je zavola\u0165 met\u00f3du Message.obtain() alebo jednu z met\u00f3d Handler.obtainMessage() , ktor\u00e1 ich vytiahne zo skupiny recyklovan\u00fdch objektov. Prepojenie vytvorenej triedy Handler s triedou HandlerThread Trieda HandlerThread obsahuje tzv. Looper , ktor\u00fd treba prepoji\u0165 s vytvorenou triedou Handler . Looper z\u00edskame cez getLooper() a referenciu odovzd\u00e1me cez kon\u0161truktor triedy Handler .( new Handler(getLooper()) ). Warning Ak by sme zavolali pr\u00e1zdny kon\u0161truktor, tak tento Handler by si vy\u017eiadal Looper od vl\u00e1kna na ktorom bol vytvoren\u00fd objekt Handler . V na\u0161om pr\u00edpade by to bolo hlavn\u00e9 vl\u00e1kno a teda v\u0161etky \u00falohy by boli vykonan\u00e9 na hlavnom vl\u00e1kne a nie na pracovnom HandlerThread vl\u00e1kne. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.os.Handler ; import android.os.HandlerThread ; import android.os.Message ; import android.widget.ImageView ; import android.os.Process ; import androidx.annotation.NonNull ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); // Definovanie pracovn\u00e9ho handlera, ktor\u00fd z pridelen\u00e9ho loopera pr\u00edjima // pridelen\u00fa pr\u00e1cu private Handler mWorkerHandler ; // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); Pred \u00fapravou package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.os.HandlerThread ; import android.os.Process ; import android.widget.ImageView ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); public class MyHandlerThread extends HandlerThread { Nov\u00e9 // priority pracovn\u00e9mu vl\u00e1knu } /** * Pomocn\u00e1 met\u00f3da na inicializ\u00e1ciu HandlerThread ako pracovn\u00e9ho vl\u00e1kna */ public void prepareHandler () { mWorkerHandler = new Handler ( getLooper ()) { /* V handleMessage callback met\u00f3de sa spracov\u00e1vaj\u00fa prijat\u00e9 spravy na pracovnom vl\u00e1kne HandlerThread */ @Override public void handleMessage ( @NonNull Message msg ) { // Spracovanie prijatej spr\u00e1vy } }; } } Pred \u00fapravou // priority pracovn\u00e9mu vl\u00e1knu } }","title":"1.3 Vytvorenie pomocnej met\u00f3dy prepareHandler"},{"location":"#14-vytvorenie-pomocnej-triedy-imageurl","text":"T\u00e1to pomocn\u00e1 trieda m\u00e1 za \u00falohu definova\u0165 typ spr\u00e1vy pomocou kon\u0161tanty WHAT \u010falej dr\u017ea\u0165 url adresu obr\u00e1zku, ktor\u00fd sa m\u00e1 stiahn\u00fa\u0165 a dr\u017ea\u0165 referenciu na ImageView, v ktorom sa zobraz\u00ed s\u0165iahnut\u00fd obr\u00e1zok. Note Referencia na ImageView v ktorom sa zobraz\u00ed stiahnut\u00fd obr\u00e1zok je vo forme WeakReference , ktor\u00e1 m\u00e1 zabezpe\u010di\u0165 aby nedoch\u00e1dzalo k memory leaku v pr\u00edpade re-\u0161tartovania aplik\u00e1cie. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/ImageUrl.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.widget.ImageView ; import java.lang.ref.WeakReference ; /* D\u00e1tova trieda, ktor\u00e1 reprezentuje jeden obr\u00e1zok, ktor\u00fd sa bude s\u0165ahova\u0165 */ public class ImageUrl { public static final int WHAT = 101 ; // Identifik\u00e1tor spr\u00e1vy public final String urlOfImage ; //url adresa obr\u00e1zku /* Referancia na ImageView v ktorom sa zobraz\u00ed stiahnut\u00fd obr\u00e1zok. T\u00e1to referencia je vo forme WeakReference, ktor\u00e1 m\u00e1 zabezpe\u010di\u0165 aby nedoch\u00e1dzalo k memory leaku v pr\u00edpade restartovania aplik\u00e1cie */ public final WeakReference < ImageView > uiToShowImage ; public ImageUrl ( String urlOfImage , ImageView uiToShowImage ) { this . urlOfImage = urlOfImage ; this . uiToShowImage = new WeakReference <> ( uiToShowImage ); } }","title":"1.4 Vytvorenie pomocnej triedy ImageUrl"},{"location":"#15-vytvorenie-metody-handlerequest-urcenej-na-stiahnutie-obrazku-z-internetu-na-pracovnom-vlakne","text":"T\u00e1to pomocn\u00e1 met\u00f3da, ktor\u00e1 je spusten\u00e1 na pomocnom vl\u00e1kne ma za \u00falohu pomocou HttpURLConnection stiahnu\u0165 obr\u00e1zok z internetu a n\u00e1sledne ho odovzda\u0165 \u010falej zavolan\u00edm callback met\u00f3dy mCallback.onImageDownloaded , ktor\u00e1 je vykonan\u00e1 na UI vl\u00e1kne. Odovzdanie Runnable objektu na hlavn\u00e9 UI vl\u00e1kno Aby sa callback met\u00f3da vykonala na hlavnom UI vl\u00e1kne, je potrebn\u00e9 ju odovzda\u0165 vo forme pracovn\u00e9ho objektu Runnable cez objekt Handler , ktor\u00fd je pripojen\u00fd k hlavn\u00e9mu vl\u00e1knu ( mResponseHandler inicializ\u00e1cia je zn\u00e1zornen\u00e1 v nasleduj\u00facom kroku). mResponseHandler . post ( new Runnable () { @Override public void run () { // Spusten\u00e9 na UI vl\u00e1kne mCallback . onImageDownloaded ( imageUrl . uiToShowImage . get (), bitmap ); } }); } Note this.sleep(500) simuluje pomal\u00e9 pripojenie na internet. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.graphics.BitmapFactory ; import android.os.Handler ; import android.os.HandlerThread ; import android.os.Message ; import android.os.Trace ; import android.widget.ImageView ; import android.os.Process ; import androidx.annotation.NonNull ; import java.io.IOException ; import java.io.InputStream ; import java.net.HttpURLConnection ; import java.net.URL ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie Pred \u00fapravou package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; import android.os.Handler ; import android.os.HandlerThread ; import android.os.Message ; import android.widget.ImageView ; import android.os.Process ; import androidx.annotation.NonNull ; public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie public class MyHandlerThread extends HandlerThread { Nov\u00e9 @Override public void handleMessage ( @NonNull Message msg ) { // Spracovanie prijatej spr\u00e1vy } }; } /* Met\u00f3da na stiahnutie obr\u00e1zku z internetu, T\u00e1to met\u00f3da je je spusten\u00e1 na pracovnom vl\u00e1kne! */ private void handleRequest ( final ImageUrl imageUrl ) { try { final Bitmap bitmap ; Trace . beginSection ( \"HTTP download\" ); HttpURLConnection connection = ( HttpURLConnection ) new URL ( imageUrl . urlOfImage ) . openConnection (); connection . setRequestMethod ( \"GET\" ); bitmap = BitmapFactory . decodeStream (( InputStream ) connection . getContent ()); try { this . sleep ( 500 ); } catch ( InterruptedException e ) { e . printStackTrace (); } /* Stiahnut\u00fd obr\u00e1zok sa odovzd\u00e1 s pomocu Handler triedy UI vl\u00e1knu, ktor\u00e9 zavol\u00e1 callback met\u00f3du */ if ( bitmap != null ) { mResponseHandler . post ( new Runnable () { @Override public void run () { // Spusten\u00e9 na UI vl\u00e1kne mCallback . onImageDownloaded ( imageUrl . uiToShowImage . get (), bitmap ); } }); } } catch ( IOException e ) { e . printStackTrace (); } } } Pred \u00fapravou @Override public void handleMessage ( @NonNull Message msg ) { // Spracovanie prijatej spr\u00e1vy } }; } }","title":"1.5 Vytvorenie met\u00f3dy handleRequest ur\u010denej na stiahnutie obr\u00e1zku z internetu na pracovnom vl\u00e1kne"},{"location":"#16-uprava-konstruktora-myhandlerthread","text":"V tomto kroku uprav\u00edme kon\u0161truktor tak aby sme z\u00edskali referenciou na Handler objekt, ktor\u00fd je sp\u00e4t\u00fd s hlavn\u00fdm vl\u00e1knom a referenciu na implementovan\u00e9 rozhranie Callback \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java import android.graphics.BitmapFactory; Nov\u00e9 import android.os.Handler ; import android.os.HandlerThread ; import android.os.Message ; import android.os.Process ; import android.os.Trace ; import android.widget.ImageView ; import androidx.annotation.NonNull ; Pred \u00fapravou import android.os.Handler ; import android.os.HandlerThread ; import android.os.Message ; import android.os.Trace ; import android.widget.ImageView ; import android.os.Process ; import androidx.annotation.NonNull ; public class MyHandlerThread extends HandlerThread { Nov\u00e9 // pridelen\u00fa pr\u00e1cu private Handler mWorkerHandler ; // Referencia na Handler, ktor\u00fd je sp\u00e4t\u00fd s UI vl\u00e1knom private Handler mResponseHandler ; // Referencia na Callback rozhranie private Callback mCallback ; // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread ( Handler responseHandler , Callback callback ) { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu mResponseHandler = responseHandler ; mCallback = callback ; } /** Pred \u00fapravou // pridelen\u00fa pr\u00e1cu private Handler mWorkerHandler ; // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu } /**","title":"1.6 \u00daprava kon\u0161truktora MyHandlerThread"},{"location":"#17-spracovanie-prijatej-spravy-v-handlemessage-metode","text":"Ak prijat\u00e1 spr\u00e1va obsahuje objekt, ktor\u00fd je typu ImageUrl tak ho odo\u0161leme na spracovanie do met\u00f3dy handleRequest , ktor\u00e1 dan\u00fd obr\u00e1zok stiahne z internetu. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java public class MyHandlerThread extends HandlerThread { Nov\u00e9 @Override public void handleMessage ( @NonNull Message msg ) { // Spracovanie prijatej spr\u00e1vy // Stiahnutie obr\u00e1zkov z internetu if ( msg . obj != null && msg . obj instanceof ImageUrl ) { handleRequest (( ImageUrl ) msg . obj ); } } }; } Pred \u00fapravou @Override public void handleMessage ( @NonNull Message msg ) { // Spracovanie prijatej spr\u00e1vy } }; }","title":"1.7 Spracovanie prijatej spr\u00e1vy v handleMessage met\u00f3de"},{"location":"#18-vytvorenie-a-inicializovanie-novej-instancie-myhandlerthread","text":"V predch\u00e1dzaj\u00facom kroku sme si upravili kon\u0161truktor triedy MyHandlerThread a teraz si pomocou neho vytvor\u00edme nov\u00fa in\u0161tanciu tejto triedy. Note V kroku 1.4 sme triedu Handler museli prepoji\u0165 manu\u00e1lne s Looperom pomocou met\u00f3dy getLooper . V tomto pr\u00edpade pr\u00e1zdny kon\u0161tuktor automaticky pripoj\u00ed Looper hlavn\u00e9ho vl\u00e1kna s triedou Handler . \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java package sk.uniza.handlerthreadcvicenie; Nov\u00e9 import android.graphics.Bitmap ; import android.os.Bundle ; import android.os.Handler ; import android.widget.ImageView ; import android.widget.LinearLayout ; import androidx.appcompat.app.AppCompatActivity ; public class MainActivity extends AppCompatActivity implements MyHandlerThread . Callback { private LinearLayout imageContainer ; private MyHandlerThread myHandlerThread ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); myHandlerThread = new MyHandlerThread ( new Handler (), this ); myHandlerThread . start (); myHandlerThread . prepareHandler (); } @Override Pred \u00fapravou import android.graphics.Bitmap ; import android.os.Bundle ; import android.widget.ImageView ; import androidx.appcompat.app.AppCompatActivity ; public class MainActivity extends AppCompatActivity implements MyHandlerThread . Callback { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); } @Override","title":"1.8 Vytvorenie a inicializovanie novej in\u0161tancie MyHandlerThread"},{"location":"#19-vytvorenie-a-odoslanie-zoznamu-obrazkov-na-stiahnutie","text":"\ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java import androidx.appcompat.app.AppCompatActivity; Nov\u00e9 public class MainActivity extends AppCompatActivity implements MyHandlerThread . Callback { // Url online slu\u017eby, ktor\u00e1 generuje obr\u00e1zky s textom private String imageUrlLink = \"https://dummyimage.com/300/09f/fff\" + \".png&text=\" ; private LinearLayout imageContainer ; private MyHandlerThread myHandlerThread ; Pred \u00fapravou public class MainActivity extends AppCompatActivity implements MyHandlerThread . Callback { private LinearLayout imageContainer ; private MyHandlerThread myHandlerThread ; public class MainActivity extends AppCompatActivity Nov\u00e9 protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); imageContainer = findViewById ( R . id . imageContainer ); myHandlerThread = new MyHandlerThread ( new Handler (), this ); myHandlerThread . start (); myHandlerThread . prepareHandler (); } @Override protected void onStart () { super . onStart (); for ( Integer i = 0 ; i < 10 ; i ++ ) { ImageView imageView = new ImageView ( this ); // Informa\u010dn\u00fd obr\u00e1zok, \u017ee prebieha \u0161tahovanie imageView . setImageResource ( R . drawable . loading ); imageContainer . addView ( imageView ); // Zavolanie pomocnej met\u00f3dy na ulo\u017eenie spr\u00e1vy do z\u00e1sob\u00edka. // Spr\u00e1vy zo z\u00e1sobn\u00edka s\u00fa spracovan\u00e9 na pracovnom vl\u00e1kne myHandlerThread . queueTask ( new ImageUrl ( imageUrlLink . concat ( \"img+\" + i ), imageView )); } } @Override public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ) { Pred \u00fapravou protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); myHandlerThread = new MyHandlerThread ( new Handler (), this ); myHandlerThread . start (); myHandlerThread . prepareHandler (); } @Override public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ) { Vytvorenie pomocnej met\u00f3dy na posunutie spr\u00e1vy pracovn\u00e9mu HandlerThread vl\u00e1knu. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java public class MyHandlerThread extends HandlerThread { Nov\u00e9 }; } /** * Pomocn\u00e1 met\u00f3da na posunutie spr\u00e1vy pracovn\u00e9mu HandlerThread vl\u00e1knu * * @param imageUrl - obr\u00e1zok, ktor\u00fd sa m\u00e1 stiahnu\u0165 */ public void queueTask ( ImageUrl imageUrl ) { mWorkerHandler . obtainMessage ( imageUrl . WHAT , imageUrl ) . sendToTarget (); } /* Met\u00f3da na stiahnutie obr\u00e1zku z internetu , T\u00e1to met\u00f3da je je spusten\u00e1 na pracovnom vl\u00e1kne ! Pred \u00fapravou }; } /* Met\u00f3da na stiahnutie obr\u00e1zku z internetu , T\u00e1to met\u00f3da je je spusten\u00e1 na pracovnom vl\u00e1kne !","title":"1.9 Vytvorenie a odoslanie zoznamu obr\u00e1zkov na stiahnutie"},{"location":"#110-zobrazenie-stiahnuteho-obrazku","text":"\ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java public class MainActivity extends AppCompatActivity Nov\u00e9 @Override public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ) { // Otestovanie \u010di ImageView bol vytvoren\u00fd v rovnakom kontexte. V // pr\u00edpade re\u0161tatovania aplik\u00e1cie, mo\u017ee ImageView poch\u00e1dza\u0165 z u\u017e // zaniknutej in\u0161tancie Aplik\u00e1cie. if ( imageView . getContext () == this ) imageView . setImageBitmap ( bitmap ); } } Pred \u00fapravou @Override public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ) { } }","title":"1.10 Zobrazenie stiahnut\u00e9ho obr\u00e1zku"},{"location":"#111-pridanie-povolenia-pre-pristup-na-internet","text":"\ud83d\uddb9 app/src/main/AndroidManifest.xml Nov\u00e9 < manifest xmlns : android = \"http://schemas.android.com/apk/res/android\" package = \"sk.uniza.handlerthreadcvicenie\" > < uses - permission android : name = \"android.permission.INTERNET\" /> < application android : allowBackup = \"true\" android : icon = \"@mipmap/ic_launcher\" Pred \u00fapravou < manifest xmlns : android = \"http://schemas.android.com/apk/res/android\" package = \"sk.uniza.handlerthreadcvicenie\" > < application android : allowBackup = \"true\" android : icon = \"@mipmap/ic_launcher\" Note Po tomto kroku by mala by\u0165 aplik\u00e1cia spustite\u013en\u00e1 a funk\u010dn\u00e1. Ale pri re\u0161tarte v plyvom konfigura\u010dnej zmeny(napr. rotacia obrazovky) doch\u00e1dza pri op\u00e4tovnom spusten\u00ed k vytvoreniu novej in\u0161tancie MyHandlerThreadu . \u013dubovoln\u00e9 pracovn\u00e9 vl\u00e1kno( Thread , HandlerThread alebo aj vl\u00e1kno sp\u00e4t\u00e9 s AsyncTask ) nie je ovplyvnen\u00e9m \u017eivotn\u00fdm cyklom aktivity, \u010do znamen\u00e1, \u017ee bude na pozad\u00ed be\u017ea\u0165 \u010falej. \u010c\u00edm viacej budeme ot\u00e1\u010da\u0165 zariadenia t\u00fdm viac in\u0161tanci\u00ed n\u00e1m bude vznika\u0165. vi\u010f obr\u00e1zok s CPU profilera: Okrem vzniku nov\u00fdch in\u0161tanci\u00ed, ka\u017ed\u00e9 pracovn\u00e9 vl\u00e1kno malo frontu pridelen\u00fdch spr\u00e1v a teda v\u0161etky vl\u00e1kna, ktor\u00e9 e\u0161te nevypr\u00e1zdnili svoju frontu \u00faloh \u010falej s\u0165ahovali obr\u00e1zky aj ke\u010f sa u\u017e nepou\u017eij\u00fa. vi\u010f obr\u00e1zok s CPU profilera: Jednoduch\u00e9 rie\u0161enie toho probl\u00e9mu je uk\u00e1zan\u00e9 v nasleduj\u00facom kroku.","title":"1.11 Pridanie povolenia pre pr\u00edstup na internet"},{"location":"#112-restart-aplikacie-vplyvom-konfiguracnej-zmeny-minimalne-riesenie","text":"Zavolan\u00edm v met\u00f3de onDestroy met\u00f3du z triedy HandlerThread .quit() vyma\u017eeme zvy\u0161n\u00e9 \u00falohy z fronty spr\u00e1v, ktor\u00e9 e\u0161te neboli spracovan\u00e9. Na aktu\u00e1lne vykon\u00e1van\u00fa \u00falohu to nem\u00e1 vplyv a teda obr\u00e1zok sa stiahne. HandlerThread vl\u00e1kno prejde do 'idle' stavu a \u010dasom ho syst\u00e9m odstr\u00e1ni. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java Nov\u00e9 package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; Pred \u00fapravou package sk.uniza.handlerthreadcvicenie ; import android.graphics.Bitmap ; public class MainActivity extends AppCompatActivity Nov\u00e9 if ( imageView . getContext () == this ) imageView . setImageBitmap ( bitmap ); } @Override protected void onDestroy () { super . onDestroy (); myHandlerThread . quit (); } } Pred \u00fapravou if ( imageView . getContext () == this ) imageView . setImageBitmap ( bitmap ); } }","title":"1.12 Re\u0161tart aplik\u00e1cie vplyvom konfigura\u010dnej zmeny. Minim\u00e1lne rie\u0161enie"},{"location":"#20-vyuzitie-singleton-jedinacik-navrhoveho-vzoru","text":"V predch\u00e1dzaj\u00facom pr\u00edpade pri ka\u017edom re\u0161tarte aplik\u00e1cie n\u00e1m vznik\u00e1 nov\u00e1 in\u0161tancia triedy MyHandlerThread , \u010do nieje optim\u00e1lne rie\u0161enie. V tomto kroku prerob\u00edme p\u00f4vodn\u00e9 rie\u0161enie s vyu\u017eit\u00edm n\u00e1vrhov\u00e9ho vzoru Singleton, tak aby existovala iba jedna jedin\u00e1 in\u0161tancia triedy MyHandlerThread . Note Singleton (jednin\u00e1\u010dik) znamen\u00e1, \u017ee trieda, ktor\u00e1 implementuje tento n\u00e1vrhov\u00fd vzor, m\u00e1 iba jednu jedin\u00fa in\u0161tanciu v celom programe. T\u00e1to in\u0161tancie je zdie\u013ean\u00e1 medzi jednotliv\u00fdmi komponentami aplik\u00e1cie. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java public class MainActivity extends AppCompatActivity Nov\u00e9 super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); imageContainer = findViewById ( R . id . imageContainer ); myHandlerThread = MyHandlerThread . getInstance ( new Handler (), this ); if ( ! myHandlerThread . isAlive ()) { // Iba pri prvom spusten\u00ed mus\u00ed prebehn\u00fa\u0165 inicializ\u00e1cia // HandlerThread triedy myHandlerThread . start (); myHandlerThread . prepareHandler (); } } @Override Pred \u00fapravou super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); imageContainer = findViewById ( R . id . imageContainer ); myHandlerThread = new MyHandlerThread ( new Handler (), this ); myHandlerThread . start (); myHandlerThread . prepareHandler (); } @Override public class MainActivity extends AppCompatActivity Nov\u00e9 @Override protected void onDestroy () { super . onDestroy (); } } Pred \u00fapravou @Override protected void onDestroy () { super . onDestroy (); myHandlerThread . quit (); } } \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java import java.net.URL; Nov\u00e9 public class MyHandlerThread extends HandlerThread { // Referencia na vytvoren\u00fa \u0161tanciu MyHandlerThread private static MyHandlerThread instance = null ; // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); Pred \u00fapravou public class MyHandlerThread extends HandlerThread { // N\u00e1zov vl\u00e1kna, ktor\u00fd je zobrazen\u00fd pri debugovan\u00ed aplik\u00e1cie private static final String TAG = MyHandlerThread . class . getSimpleName (); public class MyHandlerThread extends HandlerThread { Nov\u00e9 public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu } public static MyHandlerThread getInstance ( @NonNull Handler responseHandler , @NonNull Callback callback ) { if ( instance == null || ! instance . isAlive ()) { instance = new MyHandlerThread (); } instance . mResponseHandler = responseHandler ; instance . mCallback = callback ; return instance ; } /** Pred \u00fapravou public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread ( Handler responseHandler , Callback callback ) { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie // priority pracovn\u00e9mu vl\u00e1knu mResponseHandler = responseHandler ; mCallback = callback ; } /**","title":"2.0 Vyu\u017eitie Singleton (jedin\u00e1\u010dik) n\u00e1vrhov\u00e9ho vzoru"},{"location":"#21-optimalizacia-s-pohladu-restartovania-aktivity","text":"\ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java public class MainActivity extends AppCompatActivity Nov\u00e9 @Override protected void onDestroy () { super . onDestroy (); myHandlerThread . onDestroy (); } } Pred \u00fapravou @Override protected void onDestroy () { super . onDestroy (); } } \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java public class MyHandlerThread extends HandlerThread { Nov\u00e9 . sendToTarget (); } /** * Pomocn\u00e1 met\u00f3da, ktor\u00e1 m\u00e1 by\u0165 spusten\u00e1 ke\u010f d\u00f4jde k re\u0161tartu aktivity */ public void onDestroy () { // Odstr\u00e1nenie v\u0161etk\u00fdch e\u0161te nestiahnut\u00fdch url adries so z\u00e1sobn\u00edka mWorkerHandler . removeMessages ( ImageUrl . WHAT ); } /* Met\u00f3da na stiahnutie obr\u00e1zku z internetu , T\u00e1to met\u00f3da je je spusten\u00e1 na pracovnom vl\u00e1kne ! Pred \u00fapravou . sendToTarget (); } /* Met\u00f3da na stiahnutie obr\u00e1zku z internetu , T\u00e1to met\u00f3da je je spusten\u00e1 na pracovnom vl\u00e1kne !","title":"2.1 Optimaliz\u00e1cia s pohladu re\u0161tartovania aktivity"},{"location":"#22-bezpecny-pristupu-k-zdielanym-premennym-z-viacerych-vlaken","text":"V pr\u00edpade, kedy k zdie\u013ean\u00fdm premenn\u00fdm pristupuje viacero vl\u00e1ken, je nutn\u00e9 zabezpe\u010di\u0165 tento pr\u00edstup synchronization blokom do ktor\u00e9 ma pr\u00edstup v \u010dase iba jedin\u00e9 vl\u00e1kno. T\u00e1to problematika je rozsiahla, ale je nutn\u00e9 jej porozumie\u0165 aby n\u00e1m aplik\u00e1cia fungovala za v\u0161etk\u00fdch okolnost\u00ed. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java public class MyHandlerThread extends HandlerThread { Nov\u00e9 private volatile Handler mResponseHandler ; // Referencia na Callback rozhranie private Callback mCallback ; // Objekt ur\u010den\u00fd na zabezpe\u010denie bezpe\u010dn\u00e9ho pr\u00edstupu pri vyu\u017eit\u00ed vl\u00e1ken private volatile Object syncObj = new Object (); // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { Pred \u00fapravou private Handler mResponseHandler ; // Referencia na Callback rozhranie private Callback mCallback ; // Rozhranie pomocou ktor\u00e9ho sa odovzd\u00e1 stiahnut\u00fd obr\u00e1zok public interface Callback { public class MyHandlerThread extends HandlerThread { Nov\u00e9 if ( instance == null || ! instance . isAlive ()) { instance = new MyHandlerThread (); } synchronized ( instance . syncObj ) { instance . mResponseHandler = responseHandler ; instance . mCallback = callback ; } return instance ; } Pred \u00fapravou if ( instance == null || ! instance . isAlive ()) { instance = new MyHandlerThread (); } instance . mResponseHandler = responseHandler ; instance . mCallback = callback ; return instance ; } public class MyHandlerThread extends HandlerThread { Nov\u00e9 public void onDestroy () { // Odstr\u00e1nenie v\u0161etk\u00fdch e\u0161te nestiahnut\u00fdch url adries so z\u00e1sobn\u00edka mWorkerHandler . removeMessages ( ImageUrl . WHAT ); // Bezpe\u010dn\u00e9 vynulovanie referencie na Handler, ktor\u00fd pri re\u0161tarte // aktivity bude po dobu re\u0161tartu neplatn\u00e1 synchronized ( syncObj ) { mResponseHandler = null ; } } /* Pred \u00fapravou public void onDestroy () { // Odstr\u00e1nenie v\u0161etk\u00fdch e\u0161te nestiahnut\u00fdch url adries so z\u00e1sobn\u00edka mWorkerHandler . removeMessages ( ImageUrl . WHAT ); } /* public class MyHandlerThread extends HandlerThread { Nov\u00e9 Stiahnut\u00fd obr\u00e1zok sa odovzd\u00e1 s pomocu Handler triedy UI vl\u00e1knu , ktor\u00e9 zavol\u00e1 callback met\u00f3du */ // Bezpe\u010dn\u00fd pr\u00edstup z pracovn\u00e9ho vl\u00e1kna synchronized ( syncObj ) { // Overenie, \u017ee referencia na Handler je platn\u00e1 if ( mResponseHandler != null && bitmap != null ) { mResponseHandler . post ( new Runnable () { @Override public void run () { // Spusten\u00e9 na UI vl\u00e1kne mCallback . onImageDownloaded ( imageUrl . uiToShowImage . get (), bitmap ); } }); } } } catch ( IOException e ) { Pred \u00fapravou Stiahnut\u00fd obr\u00e1zok sa odovzd\u00e1 s pomocu Handler triedy UI vl\u00e1knu , ktor\u00e9 zavol\u00e1 callback met\u00f3du */ if ( bitmap != null ) { mResponseHandler . post ( new Runnable () { @Override public void run () { // Spusten\u00e9 na UI vl\u00e1kne mCallback . onImageDownloaded ( imageUrl . uiToShowImage . get (), bitmap ); } }); } } catch ( IOException e ) {","title":"2.2 Bezpe\u010dn\u00fd pr\u00edstupu k zdie\u013ean\u00fdm premenn\u00fdm z viacer\u00fdch vl\u00e1ken"},{"location":"#23-aplikovanie-cache-na-rychle-nacitanie-uz-stiahnutych-obrazkov","text":"Pre zamedzenie op\u00e4tovn\u00e9ho s\u0165ahovania implementujeme LRU cache do ktorej budeme zapisova\u0165 stiahnut\u00e9 obr\u00e1zky a pri re\u0161tarte sa obr\u00e1zky miesto internetu na\u010d\u00edtaj\u00fa z tejto cache. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java import android.os.Handler; Nov\u00e9 import android.os.HandlerThread ; import android.os.Message ; import android.os.Process ; import android.widget.ImageView ; import androidx.annotation.NonNull ; import androidx.collection.LruCache ; import java.io.IOException ; import java.io.InputStream ; Pred \u00fapravou import android.os.HandlerThread ; import android.os.Message ; import android.os.Process ; import android.os.Trace ; import android.widget.ImageView ; import androidx.annotation.NonNull ; import java.io.IOException ; import java.io.InputStream ; public class MyHandlerThread extends HandlerThread { Nov\u00e9 public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } // Cache na ulo\u017eenie s\u0165ahovan\u00fdch obr\u00e1zkov final int cacheSize = 4 * 1024 * 1024 ; // 4MiB LruCache < String , Bitmap > bitmapCache = new LruCache < String , Bitmap > ( cacheSize ) { protected int sizeOf ( String key , Bitmap value ) { return value . getByteCount (); } }; public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie Pred \u00fapravou public void onImageDownloaded ( ImageView imageView , Bitmap bitmap ); } public MyHandlerThread () { super ( TAG ); setPriority ( Process . THREAD_PRIORITY_BACKGROUND ); //Nastavenie public class MyHandlerThread extends HandlerThread { Nov\u00e9 try { final Bitmap bitmap ; // Na\u010d\u00edtanie obr\u00e1zku z cache(kl\u00fa\u010d je url adresa obr\u00e1zku), ak nebol // n\u00e1jden\u00fd met\u00f3da vr\u00e1ti null hodnotu Bitmap bitmapTmp = bitmapCache . get ( imageUrl . urlOfImage ); if ( bitmapTmp == null ) { HttpURLConnection connection = ( HttpURLConnection ) new URL ( imageUrl . urlOfImage ) . openConnection (); connection . setRequestMethod ( \"GET\" ); bitmap = BitmapFactory . decodeStream (( InputStream ) connection . getContent ()); bitmapCache . put ( imageUrl . urlOfImage , bitmap ); try { this . sleep ( 500 ); } catch ( InterruptedException e ) { e . printStackTrace (); } } else { bitmap = bitmapTmp ; } /* Stiahnut\u00fd obr\u00e1zok sa odovzd\u00e1 s pomocu Handler triedy UI vl\u00e1knu , ktor\u00e9 zavol\u00e1 callback met\u00f3du Pred \u00fapravou try { final Bitmap bitmap ; Trace . beginSection ( \"HTTP download\" ); HttpURLConnection connection = ( HttpURLConnection ) new URL ( imageUrl . urlOfImage ) . openConnection (); connection . setRequestMethod ( \"GET\" ); bitmap = BitmapFactory . decodeStream (( InputStream ) connection . getContent ()); try { this . sleep ( 500 ); } catch ( InterruptedException e ) { e . printStackTrace (); } /* Stiahnut\u00fd obr\u00e1zok sa odovzd\u00e1 s pomocu Handler triedy UI vl\u00e1knu , ktor\u00e9 zavol\u00e1 callback met\u00f3du","title":"2.3 Aplikovanie Cache na r\u00fdchle na\u010d\u00edtanie u\u017e stiahnut\u00fdch obr\u00e1zkov"},{"location":"#30-implementovanie-lifecycle-androidx-komponentu","text":"Komponenty, ktor\u00e9 vn\u00edmaj\u00fa \u017eivotn\u00fd cyklus vykon\u00e1vaj\u00fa ur\u010dit\u00e9 akcie pri zmene stavu \u017eivotn\u00e9ho cyklu in\u00e9ho komponentu, ako s\u00fa aktivity a fragmenty. Tieto komponenty v\u00e1m pom\u00f4\u017eu vytvori\u0165 lep\u0161ie usporiadan\u00fd a \u010dasto \u0161t\u00edhlej\u0161\u00ed k\u00f3d, ktor\u00fd sa \u013eah\u0161ie udr\u017euje. Be\u017en\u00fdm vzorcom je implement\u00e1cia \u010dinnost\u00ed z\u00e1visl\u00fdch komponentov do \u017eivotn\u00e9ho cyklu met\u00f3d aktiv\u00edt alebo fragmentov. Tento model v\u0161ak vedie k zlej organiz\u00e1cii k\u00f3d ak mno\u017eeniu ch\u00fdb. Pou\u017eit\u00edm komponentov s vyu\u017eit\u00edm LifeCycle \u017eivotn\u00e9ho cyklu m\u00f4\u017eete presun\u00fa\u0165 k\u00f3d z\u00e1visl\u00fdch komponentov z met\u00f3d \u017eivotn\u00e9ho cyklu aktivity/fragmentu do samotn\u00fdch komponentov. androidx.lifecycle Bal\u00ed\u010dek obsahuje triedy a rozhrania, ktor\u00e9 umo\u017e\u0148uj\u00fa vytv\u00e1ra\u0165 komponenty, ktor\u00e9 s\u00fa s\u00fa\u010das\u0165ou \u017eivotn\u00e9ho cyklu aktivity/fragmentu, ktor\u00e9 m\u00f4\u017eu automaticky upravi\u0165 svoje spr\u00e1vanie v z\u00e1vislosti na aktu\u00e1lnom stave \u017eivotn\u00e9ho cyklu aktivity alebo fragmentu. V\u00e4\u010d\u0161ina komponentov aplik\u00e1cie, ktor\u00e9 s\u00fa definovan\u00e9 v platforme Android Framework, je k nim pripojen\u00e1 so \u017eivotn\u00fdm cyklom. \u017divotn\u00e9 cykly s\u00fa spravovan\u00e9 opera\u010dn\u00fdm syst\u00e9mom alebo Framework k\u00f3dom be\u017eiacim vo va\u0161om procese. S\u00fa z\u00e1kladom fungovania syst\u00e9mu Android a va\u0161a aplik\u00e1cia ich mus\u00ed re\u0161pektova\u0165. Ak tak neurob\u00edte, m\u00f4\u017ee to sp\u00f4sobi\u0165 memory leak alebo dokonca zlyhanie aplik\u00e1cie. \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MainActivity.java public class MainActivity extends AppCompatActivity Nov\u00e9 super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); imageContainer = findViewById ( R . id . imageContainer ); myHandlerThread = MyHandlerThread . getInstance ( new Handler (), this , getLifecycle ()); if ( ! myHandlerThread . isAlive ()) { // Iba pri prvom spusten\u00ed mus\u00ed prebehn\u00fa\u0165 inicializ\u00e1cia Pred \u00fapravou super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); imageContainer = findViewById ( R . id . imageContainer ); myHandlerThread = MyHandlerThread . getInstance ( new Handler (), this ); if ( ! myHandlerThread . isAlive ()) { // Iba pri prvom spusten\u00ed mus\u00ed prebehn\u00fa\u0165 inicializ\u00e1cia public class MainActivity extends AppCompatActivity Nov\u00e9 imageView . setImageBitmap ( bitmap ); } @Override protected void onDestroy () { super . onDestroy (); } } Pred \u00fapravou imageView . setImageBitmap ( bitmap ); } @Override protected void onDestroy () { super . onDestroy (); myHandlerThread . onDestroy (); } } \ud83d\uddb9 app/src/main/java/sk/uniza/handlerthreadcvicenie/MyHandlerThread.java import android.widget.ImageView; Nov\u00e9 import androidx.annotation.NonNull ; import androidx.collection.LruCache ; import androidx.lifecycle.Lifecycle ; import androidx.lifecycle.LifecycleObserver ; import androidx.lifecycle.OnLifecycleEvent ; import java.io.IOException ; import java.io.InputStream ; import java.net.HttpURLConnection ; import java.net.URL ; public class MyHandlerThread extends HandlerThread implements LifecycleObserver { // Referencia na vytvoren\u00fa \u0161tanciu MyHandlerThread private static MyHandlerThread instance = null ; Pred \u00fapravou import androidx.annotation.NonNull ; import androidx.collection.LruCache ; import java.io.IOException ; import java.io.InputStream ; import java.net.HttpURLConnection ; import java.net.URL ; public class MyHandlerThread extends HandlerThread { // Referencia na vytvoren\u00fa \u0161tanciu MyHandlerThread private static MyHandlerThread instance = null ; public class MyHandlerThread extends HandlerThread { Nov\u00e9 } public static MyHandlerThread getInstance ( @NonNull Handler responseHandler , @NonNull Callback callback , @NonNull Lifecycle lifecycle ) { if ( instance == null || ! instance . isAlive ()) { instance = new MyHandlerThread (); Pred \u00fapravou } public static MyHandlerThread getInstance ( @NonNull Handler responseHandler , @NonNull Callback callback ) { if ( instance == null || ! instance . isAlive ()) { instance = new MyHandlerThread (); public class MyHandlerThread extends HandlerThread { Nov\u00e9 synchronized ( instance . syncObj ) { instance . mResponseHandler = responseHandler ; instance . mCallback = callback ; // Zaregistrovanie LifeCycleObserver, ktor\u00fdm je t\u00e1to trieda // pripojen\u00e1 na \u017eivotn\u00fd cyklus nadradenej aktivity lifecycle . addObserver ( instance ); } return instance ; } Pred \u00fapravou synchronized ( instance . syncObj ) { instance . mResponseHandler = responseHandler ; instance . mCallback = callback ; } return instance ; } public class MyHandlerThread extends HandlerThread { Nov\u00e9 /** * Pomocn\u00e1 met\u00f3da, ktor\u00e1 m\u00e1 by\u0165 spusten\u00e1 ke\u010f d\u00f4jde k re\u0161tartu aktivity * T\u00e1to met\u00f3da je teraz pripojen\u00e1 na \u017eivotn\u00fd cyklus nadradenej aktivity */ @OnLifecycleEvent ( Lifecycle . Event . ON_DESTROY ) public void onDestroy () { // Odstr\u00e1nenie v\u0161etk\u00fdch e\u0161te nestiahnut\u00fdch url adries so z\u00e1sobn\u00edka mWorkerHandler . removeMessages ( ImageUrl . WHAT ); Pred \u00fapravou /** * Pomocn\u00e1 met\u00f3da, ktor\u00e1 m\u00e1 by\u0165 spusten\u00e1 ke\u010f d\u00f4jde k re\u0161tartu aktivity */ public void onDestroy () { // Odstr\u00e1nenie v\u0161etk\u00fdch e\u0161te nestiahnut\u00fdch url adries so z\u00e1sobn\u00edka mWorkerHandler . removeMessages ( ImageUrl . WHAT );","title":"3.0 Implementovanie LifeCycle AndroidX komponentu"}]}